// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Sources/PeerLinks/messages.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct P_Hello {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 = 0

  var peerID: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct P_Shake {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isDuplicate: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct P_Link {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tbs: P_Link.TBS {
    get {return _storage._tbs ?? P_Link.TBS()}
    set {_uniqueStorage()._tbs = newValue}
  }
  /// Returns true if `tbs` has been explicitly set.
  var hasTbs: Bool {return _storage._tbs != nil}
  /// Clears the value of `tbs`. Subsequent reads from it will return its default value.
  mutating func clearTbs() {_uniqueStorage()._tbs = nil}

  /// crypto_sign_detached(signature, tbs, parentSecretKey)
  var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TBS {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var trusteePubKey: Data = SwiftProtobuf.Internal.emptyData

    var trusteeDisplayName: String = String()

    var validFrom: Double = 0

    var validTo: Double = 0

    /// NOTE: This MUST be filled either by sender/recipient before
    /// generating/verifying the signature below.
    var channelID: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct P_Invite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelPubKey: Data = SwiftProtobuf.Internal.emptyData

  var channelName: String = String()

  var chain: [P_Link] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct P_EncryptedInvite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: `request_id = HASH(req.trustee_pub_key, 'peerlinks-invite')[:32]`
  var requestID: Data = SwiftProtobuf.Internal.emptyData

  var box: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Could be a QR Code, or a text message
struct P_InviteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerID: Data = SwiftProtobuf.Internal.emptyData

  var trusteePubKey: Data = SwiftProtobuf.Internal.emptyData

  var boxPubKey: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct P_ChannelMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tbs: P_ChannelMessage.TBS {
    get {return _storage._tbs ?? P_ChannelMessage.TBS()}
    set {_uniqueStorage()._tbs = newValue}
  }
  /// Returns true if `tbs` has been explicitly set.
  var hasTbs: Bool {return _storage._tbs != nil}
  /// Clears the value of `tbs`. Subsequent reads from it will return its default value.
  mutating func clearTbs() {_uniqueStorage()._tbs = nil}

  /// crypto_sign_detached(signature, tbs, leafSecretKey)
  var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// First message on any channel
  struct Root {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Body {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var body: OneOf_Body? {
      get {return _storage._body}
      set {_uniqueStorage()._body = newValue}
    }

    var root: P_ChannelMessage.Root {
      get {
        if case .root(let v)? = _storage._body {return v}
        return P_ChannelMessage.Root()
      }
      set {_uniqueStorage()._body = .root(newValue)}
    }

    var json: String {
      get {
        if case .json(let v)? = _storage._body {return v}
        return String()
      }
      set {_uniqueStorage()._body = .json(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Body: Equatable {
      case root(P_ChannelMessage.Root)
      case json(String)

    #if !swift(>=4.1)
      static func ==(lhs: P_ChannelMessage.Body.OneOf_Body, rhs: P_ChannelMessage.Body.OneOf_Body) -> Bool {
        switch (lhs, rhs) {
        case (.root(let l), .root(let r)): return l == r
        case (.json(let l), .json(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct TBS {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// NOTE: can be empty only in the root message
    var parents: [Data] {
      get {return _storage._parents}
      set {_uniqueStorage()._parents = newValue}
    }

    /// height = max(p.height for p in parents)
    var height: Int64 {
      get {return _storage._height}
      set {_uniqueStorage()._height = newValue}
    }

    /// Link chain that leads from the channel's public key to the signer of
    /// this message
    var chain: [P_Link] {
      get {return _storage._chain}
      set {_uniqueStorage()._chain = newValue}
    }

    /// Floating point unix time
    var timestamp: Double {
      get {return _storage._timestamp}
      set {_uniqueStorage()._timestamp = newValue}
    }

    /// body of the message
    var body: P_ChannelMessage.Body {
      get {return _storage._body ?? P_ChannelMessage.Body()}
      set {_uniqueStorage()._body = newValue}
    }
    /// Returns true if `body` has been explicitly set.
    var hasBody: Bool {return _storage._body != nil}
    /// Clears the value of `body`. Subsequent reads from it will return its default value.
    mutating func clearBody() {_uniqueStorage()._body = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct P_Query {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cursor: P_Query.OneOf_Cursor? = nil

  var height: Int64 {
    get {
      if case .height(let v)? = cursor {return v}
      return 0
    }
    set {cursor = .height(newValue)}
  }

  var hash: Data {
    get {
      if case .hash(let v)? = cursor {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {cursor = .hash(newValue)}
  }

  var isBackward: Bool = false

  var limit: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Cursor: Equatable {
    case height(Int64)
    case hash(Data)

  #if !swift(>=4.1)
    static func ==(lhs: P_Query.OneOf_Cursor, rhs: P_Query.OneOf_Cursor) -> Bool {
      switch (lhs, rhs) {
      case (.height(let l), .height(let r)): return l == r
      case (.hash(let l), .hash(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct P_QueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var abbreviatedMessages: [P_QueryResponse.Abbreviated] = []

  var forwardHash: Data = SwiftProtobuf.Internal.emptyData

  var backwardHash: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Abbreviated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parents: [Data] = []

    var hash: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct P_Bulk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hashes: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct P_BulkResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messages: [P_ChannelMessage] = []

  var forwardIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct P_SyncRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelID: Data = SwiftProtobuf.Internal.emptyData

  var seq: UInt32 = 0

  /// `crypto_secretbox_easy(out, Content, symmetric_key)`
  var nonce: Data = SwiftProtobuf.Internal.emptyData

  var box: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TBS {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Empty for Feeds
    var chain: [P_Link] {
      get {return _storage._chain}
      set {_uniqueStorage()._chain = newValue}
    }

    var content: OneOf_Content? {
      get {return _storage._content}
      set {_uniqueStorage()._content = newValue}
    }

    var query: P_Query {
      get {
        if case .query(let v)? = _storage._content {return v}
        return P_Query()
      }
      set {_uniqueStorage()._content = .query(newValue)}
    }

    var bulk: P_Bulk {
      get {
        if case .bulk(let v)? = _storage._content {return v}
        return P_Bulk()
      }
      set {_uniqueStorage()._content = .bulk(newValue)}
    }

    var responsePubKey: Data {
      get {return _storage._responsePubKey}
      set {_uniqueStorage()._responsePubKey = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Content: Equatable {
      case query(P_Query)
      case bulk(P_Bulk)

    #if !swift(>=4.1)
      static func ==(lhs: P_SyncRequest.TBS.OneOf_Content, rhs: P_SyncRequest.TBS.OneOf_Content) -> Bool {
        switch (lhs, rhs) {
        case (.query(let l), .query(let r)): return l == r
        case (.bulk(let l), .bulk(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Content {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tbs: P_SyncRequest.TBS {
      get {return _storage._tbs ?? P_SyncRequest.TBS()}
      set {_uniqueStorage()._tbs = newValue}
    }
    /// Returns true if `tbs` has been explicitly set.
    var hasTbs: Bool {return _storage._tbs != nil}
    /// Clears the value of `tbs`. Subsequent reads from it will return its default value.
    mutating func clearTbs() {_uniqueStorage()._tbs = nil}

    /// crypto_sign_detached(signature, tbs, leafSecretKey)
    var signature: Data {
      get {return _storage._signature}
      set {_uniqueStorage()._signature = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct P_SyncResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelID: Data = SwiftProtobuf.Internal.emptyData

  var seq: UInt32 = 0

  /// Encrypted with `crypto_box_seal` using `sync_request.response_pub_key`
  /// from `SyncRequest`
  var box: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Content {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var content: OneOf_Content? {
      get {return _storage._content}
      set {_uniqueStorage()._content = newValue}
    }

    var queryResponse: P_QueryResponse {
      get {
        if case .queryResponse(let v)? = _storage._content {return v}
        return P_QueryResponse()
      }
      set {_uniqueStorage()._content = .queryResponse(newValue)}
    }

    var bulkResponse: P_BulkResponse {
      get {
        if case .bulkResponse(let v)? = _storage._content {return v}
        return P_BulkResponse()
      }
      set {_uniqueStorage()._content = .bulkResponse(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Content: Equatable {
      case queryResponse(P_QueryResponse)
      case bulkResponse(P_BulkResponse)

    #if !swift(>=4.1)
      static func ==(lhs: P_SyncResponse.Content.OneOf_Content, rhs: P_SyncResponse.Content.OneOf_Content) -> Bool {
        switch (lhs, rhs) {
        case (.queryResponse(let l), .queryResponse(let r)): return l == r
        case (.bulkResponse(let l), .bulkResponse(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct P_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct P_Notification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelID: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct P_Ping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var seq: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct P_Pong {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var seq: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct P_Packet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  var error: P_Error {
    get {
      if case .error(let v)? = _storage._content {return v}
      return P_Error()
    }
    set {_uniqueStorage()._content = .error(newValue)}
  }

  var invite: P_EncryptedInvite {
    get {
      if case .invite(let v)? = _storage._content {return v}
      return P_EncryptedInvite()
    }
    set {_uniqueStorage()._content = .invite(newValue)}
  }

  /// Synchronization
  var syncRequest: P_SyncRequest {
    get {
      if case .syncRequest(let v)? = _storage._content {return v}
      return P_SyncRequest()
    }
    set {_uniqueStorage()._content = .syncRequest(newValue)}
  }

  var syncResponse: P_SyncResponse {
    get {
      if case .syncResponse(let v)? = _storage._content {return v}
      return P_SyncResponse()
    }
    set {_uniqueStorage()._content = .syncResponse(newValue)}
  }

  /// Request synchronization on new messages
  var notification: P_Notification {
    get {
      if case .notification(let v)? = _storage._content {return v}
      return P_Notification()
    }
    set {_uniqueStorage()._content = .notification(newValue)}
  }

  /// Networking
  var ping: P_Ping {
    get {
      if case .ping(let v)? = _storage._content {return v}
      return P_Ping()
    }
    set {_uniqueStorage()._content = .ping(newValue)}
  }

  var pong: P_Pong {
    get {
      if case .pong(let v)? = _storage._content {return v}
      return P_Pong()
    }
    set {_uniqueStorage()._content = .pong(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case error(P_Error)
    case invite(P_EncryptedInvite)
    /// Synchronization
    case syncRequest(P_SyncRequest)
    case syncResponse(P_SyncResponse)
    /// Request synchronization on new messages
    case notification(P_Notification)
    /// Networking
    case ping(P_Ping)
    case pong(P_Pong)

  #if !swift(>=4.1)
    static func ==(lhs: P_Packet.OneOf_Content, rhs: P_Packet.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.error(let l), .error(let r)): return l == r
      case (.invite(let l), .invite(let r)): return l == r
      case (.syncRequest(let l), .syncRequest(let r)): return l == r
      case (.syncResponse(let l), .syncResponse(let r)): return l == r
      case (.notification(let l), .notification(let r)): return l == r
      case (.ping(let l), .ping(let r)): return l == r
      case (.pong(let l), .pong(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct P_Identity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  var secretKey: Data = SwiftProtobuf.Internal.emptyData

  var channelChains: [P_Identity.ChannelChain] = []

  var metadata: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ChannelChain {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var channelID: Data = SwiftProtobuf.Internal.emptyData

    var links: [P_Link] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct P_Channel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  var name: String = String()

  var isFeed: Bool = false

  var metadata: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "p"

extension P_Hello: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Hello"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "peer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.version)
      case 2: try decoder.decodeSingularBytesField(value: &self.peerID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.peerID.isEmpty {
      try visitor.visitSingularBytesField(value: self.peerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Hello, rhs: P_Hello) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.peerID != rhs.peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Shake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Shake"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_duplicate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.isDuplicate)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isDuplicate != false {
      try visitor.visitSingularBoolField(value: self.isDuplicate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Shake, rhs: P_Shake) -> Bool {
    if lhs.isDuplicate != rhs.isDuplicate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Link"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tbs"),
    2: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _tbs: P_Link.TBS? = nil
    var _signature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tbs = source._tbs
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._tbs)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tbs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Link, rhs: P_Link) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tbs != rhs_storage._tbs {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Link.TBS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = P_Link.protoMessageName + ".TBS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trustee_pub_key"),
    2: .standard(proto: "trustee_display_name"),
    3: .standard(proto: "valid_from"),
    4: .standard(proto: "valid_to"),
    5: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.trusteePubKey)
      case 2: try decoder.decodeSingularStringField(value: &self.trusteeDisplayName)
      case 3: try decoder.decodeSingularDoubleField(value: &self.validFrom)
      case 4: try decoder.decodeSingularDoubleField(value: &self.validTo)
      case 5: try decoder.decodeSingularBytesField(value: &self.channelID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trusteePubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.trusteePubKey, fieldNumber: 1)
    }
    if !self.trusteeDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.trusteeDisplayName, fieldNumber: 2)
    }
    if self.validFrom != 0 {
      try visitor.visitSingularDoubleField(value: self.validFrom, fieldNumber: 3)
    }
    if self.validTo != 0 {
      try visitor.visitSingularDoubleField(value: self.validTo, fieldNumber: 4)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Link.TBS, rhs: P_Link.TBS) -> Bool {
    if lhs.trusteePubKey != rhs.trusteePubKey {return false}
    if lhs.trusteeDisplayName != rhs.trusteeDisplayName {return false}
    if lhs.validFrom != rhs.validFrom {return false}
    if lhs.validTo != rhs.validTo {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Invite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Invite"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_pub_key"),
    2: .standard(proto: "channel_name"),
    3: .same(proto: "chain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.channelPubKey)
      case 2: try decoder.decodeSingularStringField(value: &self.channelName)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.chain)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelPubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelPubKey, fieldNumber: 1)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 2)
    }
    if !self.chain.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chain, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Invite, rhs: P_Invite) -> Bool {
    if lhs.channelPubKey != rhs.channelPubKey {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_EncryptedInvite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptedInvite"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "box"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.requestID)
      case 2: try decoder.decodeSingularBytesField(value: &self.box)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularBytesField(value: self.requestID, fieldNumber: 1)
    }
    if !self.box.isEmpty {
      try visitor.visitSingularBytesField(value: self.box, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_EncryptedInvite, rhs: P_EncryptedInvite) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.box != rhs.box {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_InviteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InviteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "trustee_pub_key"),
    3: .standard(proto: "box_pub_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.peerID)
      case 2: try decoder.decodeSingularBytesField(value: &self.trusteePubKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.boxPubKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peerID.isEmpty {
      try visitor.visitSingularBytesField(value: self.peerID, fieldNumber: 1)
    }
    if !self.trusteePubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.trusteePubKey, fieldNumber: 2)
    }
    if !self.boxPubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.boxPubKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_InviteRequest, rhs: P_InviteRequest) -> Bool {
    if lhs.peerID != rhs.peerID {return false}
    if lhs.trusteePubKey != rhs.trusteePubKey {return false}
    if lhs.boxPubKey != rhs.boxPubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_ChannelMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tbs"),
    2: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _tbs: P_ChannelMessage.TBS? = nil
    var _signature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tbs = source._tbs
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._tbs)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tbs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_ChannelMessage, rhs: P_ChannelMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tbs != rhs_storage._tbs {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_ChannelMessage.Root: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = P_ChannelMessage.protoMessageName + ".Root"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_ChannelMessage.Root, rhs: P_ChannelMessage.Root) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_ChannelMessage.Body: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = P_ChannelMessage.protoMessageName + ".Body"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "root"),
    2: .same(proto: "json"),
  ]

  fileprivate class _StorageClass {
    var _body: P_ChannelMessage.Body.OneOf_Body?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: P_ChannelMessage.Root?
          if let current = _storage._body {
            try decoder.handleConflictingOneOf()
            if case .root(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._body = .root(v)}
        case 2:
          if _storage._body != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._body = .json(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._body {
      case .root(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .json(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_ChannelMessage.Body, rhs: P_ChannelMessage.Body) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_ChannelMessage.TBS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = P_ChannelMessage.protoMessageName + ".TBS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parents"),
    2: .same(proto: "height"),
    3: .same(proto: "chain"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "body"),
  ]

  fileprivate class _StorageClass {
    var _parents: [Data] = []
    var _height: Int64 = 0
    var _chain: [P_Link] = []
    var _timestamp: Double = 0
    var _body: P_ChannelMessage.Body? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parents = source._parents
      _height = source._height
      _chain = source._chain
      _timestamp = source._timestamp
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedBytesField(value: &_storage._parents)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._height)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._chain)
        case 4: try decoder.decodeSingularDoubleField(value: &_storage._timestamp)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._body)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._parents.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._parents, fieldNumber: 1)
      }
      if _storage._height != 0 {
        try visitor.visitSingularInt64Field(value: _storage._height, fieldNumber: 2)
      }
      if !_storage._chain.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chain, fieldNumber: 3)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularDoubleField(value: _storage._timestamp, fieldNumber: 4)
      }
      if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_ChannelMessage.TBS, rhs: P_ChannelMessage.TBS) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parents != rhs_storage._parents {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._chain != rhs_storage._chain {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Query"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "hash"),
    3: .standard(proto: "is_backward"),
    4: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.cursor != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.cursor = .height(v)}
      case 2:
        if self.cursor != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.cursor = .hash(v)}
      case 3: try decoder.decodeSingularBoolField(value: &self.isBackward)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.limit)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.cursor {
    case .height(let v)?:
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    case .hash(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    case nil: break
    }
    if self.isBackward != false {
      try visitor.visitSingularBoolField(value: self.isBackward, fieldNumber: 3)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Query, rhs: P_Query) -> Bool {
    if lhs.cursor != rhs.cursor {return false}
    if lhs.isBackward != rhs.isBackward {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_QueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "abbreviated_messages"),
    2: .standard(proto: "forward_hash"),
    3: .standard(proto: "backward_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.abbreviatedMessages)
      case 2: try decoder.decodeSingularBytesField(value: &self.forwardHash)
      case 3: try decoder.decodeSingularBytesField(value: &self.backwardHash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.abbreviatedMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.abbreviatedMessages, fieldNumber: 1)
    }
    if !self.forwardHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.forwardHash, fieldNumber: 2)
    }
    if !self.backwardHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.backwardHash, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_QueryResponse, rhs: P_QueryResponse) -> Bool {
    if lhs.abbreviatedMessages != rhs.abbreviatedMessages {return false}
    if lhs.forwardHash != rhs.forwardHash {return false}
    if lhs.backwardHash != rhs.backwardHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_QueryResponse.Abbreviated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = P_QueryResponse.protoMessageName + ".Abbreviated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parents"),
    2: .same(proto: "hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.parents)
      case 2: try decoder.decodeSingularBytesField(value: &self.hash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parents.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.parents, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_QueryResponse.Abbreviated, rhs: P_QueryResponse.Abbreviated) -> Bool {
    if lhs.parents != rhs.parents {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Bulk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Bulk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hashes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.hashes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hashes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.hashes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Bulk, rhs: P_Bulk) -> Bool {
    if lhs.hashes != rhs.hashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_BulkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BulkResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .standard(proto: "forward_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.forwardIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if self.forwardIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.forwardIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_BulkResponse, rhs: P_BulkResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.forwardIndex != rhs.forwardIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_SyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "seq"),
    3: .same(proto: "nonce"),
    4: .same(proto: "box"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.channelID)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.seq)
      case 3: try decoder.decodeSingularBytesField(value: &self.nonce)
      case 4: try decoder.decodeSingularBytesField(value: &self.box)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 1)
    }
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 2)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 3)
    }
    if !self.box.isEmpty {
      try visitor.visitSingularBytesField(value: self.box, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_SyncRequest, rhs: P_SyncRequest) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seq != rhs.seq {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.box != rhs.box {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_SyncRequest.TBS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = P_SyncRequest.protoMessageName + ".TBS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .same(proto: "query"),
    3: .same(proto: "bulk"),
    4: .standard(proto: "response_pub_key"),
  ]

  fileprivate class _StorageClass {
    var _chain: [P_Link] = []
    var _content: P_SyncRequest.TBS.OneOf_Content?
    var _responsePubKey: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chain = source._chain
      _content = source._content
      _responsePubKey = source._responsePubKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._chain)
        case 2:
          var v: P_Query?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .query(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .query(v)}
        case 3:
          var v: P_Bulk?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .bulk(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .bulk(v)}
        case 4: try decoder.decodeSingularBytesField(value: &_storage._responsePubKey)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._chain.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chain, fieldNumber: 1)
      }
      switch _storage._content {
      case .query(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .bulk(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
      if !_storage._responsePubKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._responsePubKey, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_SyncRequest.TBS, rhs: P_SyncRequest.TBS) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chain != rhs_storage._chain {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._responsePubKey != rhs_storage._responsePubKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_SyncRequest.Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = P_SyncRequest.protoMessageName + ".Content"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tbs"),
    2: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _tbs: P_SyncRequest.TBS? = nil
    var _signature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tbs = source._tbs
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._tbs)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tbs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_SyncRequest.Content, rhs: P_SyncRequest.Content) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tbs != rhs_storage._tbs {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_SyncResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "seq"),
    3: .same(proto: "box"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.channelID)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.seq)
      case 3: try decoder.decodeSingularBytesField(value: &self.box)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 1)
    }
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 2)
    }
    if !self.box.isEmpty {
      try visitor.visitSingularBytesField(value: self.box, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_SyncResponse, rhs: P_SyncResponse) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seq != rhs.seq {return false}
    if lhs.box != rhs.box {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_SyncResponse.Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = P_SyncResponse.protoMessageName + ".Content"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "queryResponse"),
    2: .same(proto: "bulkResponse"),
  ]

  fileprivate class _StorageClass {
    var _content: P_SyncResponse.Content.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: P_QueryResponse?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .queryResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .queryResponse(v)}
        case 2:
          var v: P_BulkResponse?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .bulkResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .bulkResponse(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._content {
      case .queryResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .bulkResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_SyncResponse.Content, rhs: P_SyncResponse.Content) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Error, rhs: P_Error) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Notification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.channelID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Notification, rhs: P_Notification) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seq"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.seq)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Ping, rhs: P_Ping) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Pong: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pong"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seq"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.seq)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Pong, rhs: P_Pong) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Packet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Packet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "invite"),
    3: .standard(proto: "sync_request"),
    4: .standard(proto: "sync_response"),
    5: .same(proto: "notification"),
    6: .same(proto: "ping"),
    7: .same(proto: "pong"),
  ]

  fileprivate class _StorageClass {
    var _content: P_Packet.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: P_Error?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .error(v)}
        case 2:
          var v: P_EncryptedInvite?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .invite(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .invite(v)}
        case 3:
          var v: P_SyncRequest?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .syncRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .syncRequest(v)}
        case 4:
          var v: P_SyncResponse?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .syncResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .syncResponse(v)}
        case 5:
          var v: P_Notification?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .notification(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .notification(v)}
        case 6:
          var v: P_Ping?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .ping(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .ping(v)}
        case 7:
          var v: P_Pong?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .pong(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .pong(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._content {
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .invite(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .syncRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .syncResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .notification(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .ping(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .pong(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Packet, rhs: P_Packet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Identity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "public_key"),
    3: .standard(proto: "secret_key"),
    4: .standard(proto: "channel_chains"),
    5: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.secretKey)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.channelChains)
      case 5: try decoder.decodeSingularStringField(value: &self.metadata)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    if !self.secretKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.secretKey, fieldNumber: 3)
    }
    if !self.channelChains.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelChains, fieldNumber: 4)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Identity, rhs: P_Identity) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.secretKey != rhs.secretKey {return false}
    if lhs.channelChains != rhs.channelChains {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Identity.ChannelChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = P_Identity.protoMessageName + ".ChannelChain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "links"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.channelID)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.links)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 1)
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Identity.ChannelChain, rhs: P_Identity.ChannelChain) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension P_Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Channel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .same(proto: "name"),
    3: .standard(proto: "is_feed"),
    4: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularBoolField(value: &self.isFeed)
      case 4: try decoder.decodeSingularStringField(value: &self.metadata)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.isFeed != false {
      try visitor.visitSingularBoolField(value: self.isFeed, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: P_Channel, rhs: P_Channel) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.name != rhs.name {return false}
    if lhs.isFeed != rhs.isFeed {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
